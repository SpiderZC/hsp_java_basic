# 面向对象高级

## 类变量和类方法

### 类变量

#### 共识

1. static变量是同一个类所有对象共享

2. static类变量，在类加载的时候就生成了

#### 定义

> 类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。

#### 语法

> 访问修饰符 static 数据类型 变量名；

#### 访问

> 类名.类变量名;

#### 使用细节

##### 什么时候需要用类变量

- 当我们需要让某个类的所有对象都共享一个变量时，就可以考虑类变量(静态变量) 比如: 定义学生类，统计所有学生交多少钱。

##### 类变量与实例变量区别

- 类变量是该类的所有对象共享的，而实例变量是每个对象独享的

- 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量

- 类变量是可以通过类名.类变量名或者对象名.类变量名来访问的，推荐前者

- 实例变量不能通过类名.类变量名方式访问

- 类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了。

- 类变量的生命周期是随类的加载开始，随着类消亡而销毁的

### 类方法

#### 基本介绍

添加static关键字的方法

#### 语法

访问修饰符 static 数据返回类型 方法名() {}

#### 类方法的调用

类名.类方法名

#### 类方法的使用场景

> 当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率

> 在程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用了

#### 类方法的注意事项

1. 类方法和普通方法都是随着类的加载而加载的，将结构信息存储在方法区：

   - 类方法中无this的参数

   - 普通方法中隐含着this的参数

2. 类方法可以通过类名调用，也可以通过对象名调用

3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用

4. 类方法中不允许使用对象和对象有关的关键字。比如this和super。 普通方法可以

5. 类方法(静态方法)中只能访问静态变量或静态方法。

6. 普通成员方法，既可以访问普通变量(方法)，也可以访问静态变量

> 静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员(必须遵守访问权限)

## 理解main方法语法

### 形式

> public static void main(String[] args) {}

1. main方法是java虚拟机在调用

2. java虚拟机需要调用类的main方法，所以该方法的访问权限必须是public的

3. java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static

4. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数

5. java执行的程序 参数1 参数2 参数3

###  main方法

1. 静态方法main 可以访问本类的静态成员

2. 静态方法main不可以访问本类的非静态成员

3. 静态方法main 要访问本类的非静态成员，需要先创建对象，再调用即可

## 代码块

### 基本介绍

> 代码块又称为初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{} 包围起来
> 和方法不同，没有方法名，没有返回，没有参数,只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象的隐式调用

### 基本语法

```java
[修饰符] {
    代码
};
```

>  注意事项
> 
> 修饰符可选，只能写static
> 
> 代码块分为两种，使用static的和不使用static的
> 
> 逻辑语句可以为任何逻辑语句

；号可以写上，也可以省略。

### 优点

1. 相当于另外一个形式的构造器，可以做初始化的操作

2. 场景：如果多个构造器中的都有重复的语句，可以抽取到初始化块中，提高代码的复用性

### 代码块使用注意事项

1. static 代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次，如果时普通代码块，每创建一个对象，就执行

2. 类什么时候被加载

   -. 创建对象实例时

   - 创建子类对象实例，父类也会被加载

   - 使用类的静态成员时(静态属性，静态方法)

3. 普通的代码块，在创建对象实例时，会被隐式调用，被创建一次，就会调用一次

> 如果只是使用类的静态成员时，普通代码并不会执行

4. **创建一个对象时，在一个类调用顺序是:**

   - 调用静态代码块和静态属性初始化(注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)

   - 调用普通代码块和普通属性的初始化(注意：普通代码块和普通属性初始化的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)

5. 构造方法(构造器) 的最前面其实隐含了super() 和 调用普通代码块，新写一个类演示，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块可执行的

```java
class A {
    public A() {
        super();
        {};
        Sysout.out.ptintln("OK");
    }
}
```

6. 创建一个子类时(继承关系)，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用如下：

   - 父类的静态代码块和静态属性

   - 子类的静态代码块和属性

   - 父类的普通代码块和普通属性初始化

   - 父类的构造方法

   - 子类的普通代码块和普通属性初始化

   - 子类的构造方法

7. 静态代码块只能直接调用静态成员方法(静态属性和静态方法), 普通代码块可以调用任意成员

## 单例设计模式

### 什么是设计模式
1. 静态方法和属性的经典使用

2. 设计模式是在大量的实践中总结和理论化之后优选的代码结构，编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱 

### 什么是单例模式

1. 所谓类的单例模式，就是采取一定的方法保证在整个的软件中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法

2. 单例模式有两种方式：1. 饿汉式 2. 懒汉式

### 饿汉式和懒汉式的区别

1. 创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建

2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题。

3. 饿汉式存在资源浪费的可能，因为如果程序员一个对象都没有使用，那么饿汉式创建对象就浪费了，懒汉式则不存在这种可能

## final关键字

### 基本介绍

> final 可以修饰类、属性、方法和局部变量

1. 当不希望类被继承时，可以用final修饰

2. 当不希望父类的某个方法被子类覆盖/重写时，可以用final关键字

3. 当不希望类的某个属性的值被修改，可以用final修饰

4. 当不希望某个局部变量被修改，可以用final修饰

### 注意事项

1. final修饰的属性又叫常量，一般用XX_XX来命名

2. final修饰的属性在定义时，必须赋初始值，并且以后不能再修改，赋值可以在如下位置之一
   - 定义时： public final double TAX_RATE = 0.08;

   - 在构造器中

   - 在代码块中

3. 如果final修饰的属性是静态的，则初始化的位置只能是

   - 定义时

   - 在静态代码块中, 不能在构造其中赋值

4. final类不能继承，但是可以实例化

5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承

6. 如果一个类已经是final类了，就没有必要再将方法修饰成final方法了

7. final不能修饰构造方法

8. final和static：往往搭配使用，效率更高，底层编译器做了优化处理

9. 包装类都是final， String也是

## 抽象类

> 当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类

### 基本介绍

1. 用abstract关键字来修饰一个类时，这个类就叫抽象类

```java
访问修饰符 abstract 类名 {

}
```

2. 用abstract关键字来修饰一个方法时，这个方法就是抽象方法，访问修饰符abstract 返回类型 方法名(参数列表)；

3. 抽象类的价值更多作用在于设计，是设计者设计好后，让子类继承并实现抽象类()

### 注意事项

1. 抽象类不能被实例化

2. 抽象类不一定要包含abstract方法，抽象类可以没有abstract方法

3. 一旦类包含了abstract方法，则这个类必须声明为abstract

4. abstract只能**修饰类和方法**，不能修饰属性和其他的。

5. 抽象类可以有任意成员**抽象类的本质还是类**

6. 抽象方法不能有主体

7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类

8. 抽象方法不能和private、final和static来修饰，因为这些关键字都和重写相违背。

### 模板设计模式

## 接口

### 基本介绍

> 接口就是给出一些没有实现的方法，封装在一起，到某个类要使用的时候，在根据具体情况把这些方法写出来

```java
interface name {
    context;
    method();
}
```

1. jdk7.0之前，接口里所有的方法都没有方法体。

2. jdk8.0后，接口可以有静态方法，默认方法.
```java
interface interface01 {
    default void method01() {
    }

    static void method02() {
    }
}
```

### 注意事项

1. 接口不能被实例化

2. jdk7 接口中所有方法都是public方法 **jdk8 添加default和static**，抽象方法可以不加abstract。

3. 一个普通类实现接口，就必须将该接口的所有方法实现

4. 抽象类实现接口，可以不用实现接口的方法

5. 一个类同时可以**实现**多个接口

6. 接口中的属性，只能是final的，而且是public static final 修饰符

```java
int a = 1; // public static final int a = 1;
```

7. 接口中属性的访问形式：接口名.属性名

8. 一个接口不能**继承**其它的类，但是可以继承多个别的**接口**

```java

interface ID extends IB, IC {
}

interface IB {
}

interface IC {
}

```

9. **接口**的修饰符，只能是public或默认

### 接口 vs 继承

1. 接口和继承解决的问题不同

   - 继承的价值主要在于：解决代码的复用性和可维护性

   - 接口的价值在于：设计，设计好各种规范(方法), 让其它类去实现这些方法

2. 接口比继承更灵活

   - 接口比继承更加灵活，继承是满足is-a的关系，而接口只需满足like-a的关系

3. 接口在一定程度上实现代码解耦

### 接口的多态特性

1. 多态参数

2. 多态数组

3. 接口存在多态传递现象

## 内部类

### 基本介绍

> 一个类的内部又完整嵌套了另一个类结构，被嵌套的类称为内部类(inner class), 嵌套其他类的类称为外部类。是我们类的第五大成员，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的关系

```java
class Outer {
    class Inner {

    }
}

class Other {
}
```

### 内部类分类

#### 定义在外部局部位置上

##### 局部内部类

> 1. 局部内部类定义在方法中/代码块
> 2. 作用域在方法体或者代码块中
> 3. 本质仍然是一个类

   - 定义在外部类的局部位置，比如方法中，并且有类名

   1. 可以直接访问外部类的所有成员，包含私有的

   2. 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final。

   3. 作用域：仅仅在定义它的方法或代码块中

   4. 局部内部类---访问----》外部类的成员

   5. 外部类---访问---》局部内部类的成员

      - 访问方式：创建对象，再访问

   6. 外部其它类---不能访问-----》局部内部类 (局部内部类地位是一个局部变量)

   7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员) 去访问


##### 匿名内部类

   1. 本质仍然是一个类
   2. 内部类
   3. 该类没有名字

   > 匿名内部类是定义在外部类的局部位置，不如方法值哦个，并且没有类名

   1. 匿名内部类的基本语法

   ```java
   new 类或接口 (参数列表) {
       类体;
   };
   ```

#### 定义在外部类的成员位置上

1. 成员内部类

2. 静态内部类
